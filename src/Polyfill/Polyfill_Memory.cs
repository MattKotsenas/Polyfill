// <auto-generated />

#pragma warning disable

#if FeatureMemory

using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using Link = System.ComponentModel.DescriptionAttribute;

static partial class Polyfill
{
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3X || NET5_0_OR_GREATER
       /// <summary>
        /// Parses the source <see cref="ReadOnlySpan{Char}"/> for the specified <paramref name="separator"/>, populating the <paramref name="destination"/> span
        /// with <see cref="Range"/> instances representing the regions between the separators.
        /// </summary>
        /// <param name="source">The source span to parse.</param>
        /// <param name="destination">The destination span into which the resulting ranges are written.</param>
        /// <param name="separator">A character that delimits the regions in this instance.</param>
        /// <param name="options">A bitwise combination of the enumeration values that specifies whether to trim whitespace and include empty ranges.</param>
        /// <returns>The number of ranges written into <paramref name="destination"/>.</returns>
        /// <remarks>
        /// <para>
        /// Delimiter characters are not included in the elements of the returned array.
        /// </para>
        /// <para>
        /// If the <paramref name="destination"/> span is empty, or if the <paramref name="options"/> specifies <see cref="StringSplitOptions.RemoveEmptyEntries"/> and <paramref name="source"/> is empty,
        /// or if <paramref name="options"/> specifies both <see cref="StringSplitOptions.RemoveEmptyEntries"/> and <see cref="StringSplitOptions.TrimEntries"/> and the <paramref name="source"/> is
        /// entirely whitespace, no ranges are written to the destination.
        /// </para>
        /// <para>
        /// If the span does not contain <paramref name="separator"/>, or if <paramref name="destination"/>'s length is 1, a single range will be output containing the entire <paramref name="source"/>,
        /// subject to the processing implied by <paramref name="options"/>.
        /// </para>
        /// <para>
        /// If there are more regions in <paramref name="source"/> than will fit in <paramref name="destination"/>, the first <paramref name="destination"/> length minus 1 ranges are
        /// stored in <paramref name="destination"/>, and a range for the remainder of <paramref name="source"/> is stored in <paramref name="destination"/>.
        /// </para>
        /// </remarks>
        public static int Split(this ReadOnlySpan<char> source, Span<Range> destination, char separator, StringSplitOptions options = StringSplitOptions.None)
        {
            var foundIndexes = new List<int>();

            var searchSpan = source;
            while (searchSpan.Length > 0)
            {
                searchSpan.IndexOf(separator);
                if()
            }
            for (int i = source.IndexOf('a'); i > -1; i = s.IndexOf('a', i + 1))
            {
                // for loop end when i=-1 ('a' not found)
                foundIndexes.Add(i);
            }
            string.CheckStringSplitOptions(options);

            return SplitCore(source, destination, new ReadOnlySpan<char>(in separator), default, isAny: true, options);
        }
#endif
#if NETFRAMEWORK || NETSTANDARD || NETCOREAPP2X
    /// <summary>
    /// Indicates whether a specified value is found in a read-only span. Values are compared using IEquatable{T}.Equals(T).
    /// </summary>
    /// <param name="value">The value to search for.</param>
    /// <returns><c>true</c> if found, <c>false</c> otherwise.</returns>
    [Link("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.contains#system-memoryextensions-contains-1(system-readonlyspan((-0))-0)")]
    public static bool Contains<T>(
        this ReadOnlySpan<T> target,
        T value)
        where T : IEquatable<T>
    {
        for (var index = 0; index < target.Length; index++)
        {
            if (target[index].Equals(value))
            {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Indicates whether a specified value is found in a only span. Values are compared using IEquatable{T}.Equals(T).
    /// </summary>
    /// <param name="value">The value to search for.</param>
    /// <returns><c>true</c> if found, <c>false</c> otherwise.</returns>
    [Link("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.contains#system-memoryextensions-contains-1(system-span((-0))-0)")]
    public static bool Contains<T>(
        this Span<T> target,
        T value)
        where T : IEquatable<T>
    {
        for (var index = 0; index < target.Length; index++)
        {
            if (target[index].Equals(value))
            {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T).
    /// </summary>
    /// <param name="target">The first sequence to compare.</param>
    /// <param name="other">The second sequence to compare.</param>
    /// <returns><c>true</c> if the two sequences are equal; otherwise, <c>false</c>.</returns>
    [Link("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.sequenceequal#system-memoryextensions-sequenceequal-1(system-readonlyspan((-0))-system-readonlyspan((-0)))")]
    public static bool SequenceEqual(
        this ReadOnlySpan<char> target,
        string other) =>
        target.SequenceEqual(other.AsSpan());

    /// <summary>
    /// Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T).
    /// </summary>
    /// <param name="target">The first sequence to compare.</param>
    /// <param name="other">The second sequence to compare.</param>
    /// <returns><c>true</c> if the two sequences are equal; otherwise, <c>false</c>.</returns>
    [Link("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.sequenceequal#system-memoryextensions-sequenceequal-1(system-span((-0))-system-readonlyspan((-0)))")]
    public static bool SequenceEqual(
        this Span<char> target,
        string other) =>
        target.SequenceEqual(other.AsSpan());

    /// <summary>
    /// Determines whether a read-only character span begins with a specified value when compared using a specified <see cref="StringComparison"/> value.
    /// </summary>
    /// <param name="target">The source span.</param>
    /// <param name="other">The sequence to compare to the beginning of the source span.</param>
    /// <param name="comparison">An enumeration value that determines how span and value are compared.</param>
    /// <returns><c>true</c> if value matches the beginning of span; otherwise, <c>false</c>.</returns>
    [Link("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.startswith#system-memoryextensions-startswith-1(system-readonlyspan((-0))-system-readonlyspan((-0)))")]
    public static bool StartsWith(
        this ReadOnlySpan<char> target,
        string other,
        StringComparison comparison = StringComparison.CurrentCulture) =>
        target.StartsWith(other.AsSpan(), comparison);

    /// <summary>
    /// Determines whether a specified sequence appears at the start of a span.
    /// </summary>
    /// <param name="target">The source span.</param>
    /// <param name="other">The sequence to compare to the beginning of the source span.</param>
    /// <returns><c>true</c> if value matches the beginning of span; otherwise, <c>false</c>.</returns>
    [Link("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.startswith#system-memoryextensions-startswith-1(system-span((-0))-system-readonlyspan((-0)))")]
    public static bool StartsWith(
        this Span<char> target,
        string other) =>
        target.StartsWith(other.AsSpan());

    /// <summary>
    /// Determines whether the end of the span matches the specified value when compared using the specified <paramref name="comparison"/> option.
    /// </summary>
    /// <param name="target">The source span.</param>
    /// <param name="other">The sequence to compare to the end of the source span.</param>
    /// <param name="comparison">An enumeration value that determines how span and value are compared.</param>
    /// <returns><c>true</c> if value matches the end of span; otherwise, <c>false</c>.</returns>
    [Link("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.endswith#system-memoryextensions-endswith-1(system-readonlyspan((-0))-system-readonlyspan((-0)))")]
    public static bool EndsWith(
        this ReadOnlySpan<char> target,
        string other,
        StringComparison comparison = StringComparison.CurrentCulture) =>
        target.EndsWith(other.AsSpan(), comparison);

    /// <summary>
    /// Determines whether the specified sequence appears at the end of a span.
    /// </summary>
    /// <param name="target">The source span.</param>
    /// <param name="other">The sequence to compare to the end of the source span.</param>
    /// <returns><c>true</c> if value matches the end of span; otherwise, <c>false</c>.</returns>
    [Link("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.endswith#system-memoryextensions-endswith-1(system-span((-0))-system-readonlyspan((-0)))")]
    public static bool EndsWith(
        this Span<char> target,
        string other) =>
        target.EndsWith(other.AsSpan());
#endif
}

#endif
